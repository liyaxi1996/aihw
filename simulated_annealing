#include <iostream>
#include <stdlib.h>
#include <time.h>
#include <cmath>
#include <vector>

using namespace std;

void ReadFromFile(int* N){ //read input and target from files
    FILE* finput;
    if((finput = fopen("D:\\simulated_annealing\\input.txt","r")) == NULL){
        printf("\nConnot open file!");
        exit(1);
    }
    fscanf(finput,"%d",N);
    if((*N) < 0 || (*N) > 1000000){
        printf("Your input is wrong");
        exit(-1);
    }
    fclose(finput);
}

int HeuristicFunction(vector<int> &board,vector<int> &current,vector<int> &current1, int  N ){
    int f = 0;
    for(int i = 0 ; i < N ; i ++){
        current[board[i] + i - 1] ++;
    }
    for(int i = 0 ; i < 2*N - 1; i ++){
        if(current[i] > 0){
            f += current[i] * (current[i] - 1) / 2;
        }
    }
    for(int i = 0 ; i < N ; i ++){
        if(i - (board[i] - 1) < 0){
            current1[i - (board[i] - 1) + 2*N - 1] ++;
        }
        else{
            current1[i - (board[i] - 1)] ++;
        }
    }
    for(int i = 0 ; i < 2*N - 1; i ++){
        if(current1[i] > 0){
            f += current1[i] * (current1[i] - 1) / 2;
        }
    }
    return f;
}

void N_Queen(vector<int> &board, int N){
    int i,j;
    if(N % 6 != 2 && N % 6 != 3){
        for(i = 0; i < N/2 ; i++){
            board[i] = (i+1)*2;
        }
        j = 1;
        for( ; i < N; i++){
            board[i] = j;
            j = j + 2;
        }
    }
    else if(N % 6 == 2 || N % 6 == 3){
        int k = (N % 2 == 0)? N/2 : (N-1)/2;
        if(k % 2 == 0 && N % 2 == 0){
            i = 0;
            for(j = k ; j <= N ; j= j + 2 )
                board[i++] = j;
            for(j = 2; j <= k-2 ; j = j + 2)
                board[i ++] = j ;
            for(j = k+3; j<=N-1;j = j + 2)
                board[i++] =  j;
            for(j = 1 ; j < k+1 ; j = j + 2)
                board[i++] =  j;
            board[i] = k + 1;
        }
        else if(k % 2 == 0 && N % 2 == 1){
            i = 0;
            for(j = k ; j <= N-1 ; j= j + 2 )
                board[i++] = j;
            for(j = 2; j <= k-2 ; j = j + 2)
                board[i ++] = j ;
            for(j = k+3; j<=N-2;j = j + 2)
                board[i++] =  j;
            for(j = 1 ; j <= k+1 ; j = j + 2)
                board[i++] =  j;
            board[i] = N;
        }
        else if(k % 2 == 1 && N % 2 == 0){
            i = 0;
            for(j = k ; j <= N-1 ; j= j + 2 )
                board[i++] = j;
            for(j = 1; j <= k-2 ; j = j + 2)
                board[i ++] = j ;
            for(j = k+3; j <= N;j = j + 2)
                board[i++] =  j;
            for(j = 2 ; j < k+1 ; j = j + 2)
                board[i++] =  j;
            board[i] = k + 1;
        }
        else{
            i = 0;
            for(j = k ; j <= N-2 ; j= j + 2 )
                board[i++] = j;
            for(j = 1; j <= k-2 ; j = j + 2)
                board[i ++] = j ;
            for(j = k+3; j<=N-1;j = j + 2)
                board[i++] =  j;
            for(j = 2 ; j <= k+1 ; j = j + 2)
                board[i++] =  j;
            board[i] = N;
        }
    }
}

int delta(vector<int> &board,vector<int > &current_P, vector<int > &current_N,int a,int b, int N ){
    int Delta = 0;
    int ba = board[a];
    int bb = board[b];
    Delta = -(current_P[ba + a - 1] + current_P[bb + b - 1] - 2) + (current_P[ba + b - 1] +  current_P[bb + a - 1]);
    if(b - (bb - 1) < 0  && a - (ba - 1) < 0){
        Delta -= current_N[a - (ba - 1) + 2 * N - 1]  +  current_N[b - (bb - 1) + 2 * N - 1] - 2 ;
    }
    else if(b - (bb - 1) < 0 && a - (ba - 1) >= 0){
        Delta -= current_N[a - (ba - 1)]  +  current_N[b - (bb - 1) + 2 * N - 1] - 2 ;
    }
    else if(b - (bb - 1) >= 0 && a - (ba - 1) < 0 ){
        Delta -= current_N[a - (ba - 1) + 2 * N - 1]  +  current_N[b - (bb - 1)] - 2 ;
    }
    else{
        Delta -= current_N[a - (ba - 1)] + current_N[b - (bb - 1)] - 2;
    }
    if(a - (bb - 1 ) < 0  && b - (ba - 1) < 0){
        Delta += current_N[a - (bb - 1) + 2*N - 1] + current_N[b - (ba - 1) + 2*N - 1];
    }
    else if(a - (bb - 1 ) < 0  && b - (ba - 1) >= 0){
        Delta += current_N[a - (bb - 1) + 2*N - 1] + current_N[b - (ba - 1)];
    }
    else if(a - (bb - 1 ) >= 0  && b - (ba - 1) < 0){
        Delta += current_N[a - (bb - 1)] + current_N[b - (ba - 1) + 2*N - 1];
    }
    else{
        Delta += current_N[a - (bb - 1)] + current_N[b - (ba - 1)];
    }
    if(bb + b == ba + a)
        Delta ++;
    if(bb + a == ba + b)
        Delta ++;
    if(b - bb  == a - ba)
        Delta ++;
    if(a - bb == b - ba)
        Delta ++;
    return Delta;
}

int FindNext(vector<int > &current_black,vector<int > &current_white,vector<int > &DiaP_Black,vector<int > &DiaN_Black,vector<int > &DiaP_White,vector<int > &DiaN_White,
             int N,int* a,int* b,int* c,int reverse){
    srand((unsigned)time(0));
    int Delta = 0 ;
    int flag;
    int max = -1;
    int j;
    int Ex;
    flag = 0;
    for(int i = 0 ; i < N ; i ++) {
        int num = DiaP_Black[current_black[i] + i - 1] - 1;
        if(i - (current_black[i] - 1) < 0){
            num += DiaN_Black[i - (current_black[i] - 1) + 2 * N - 1] - 1 ;
        }
        else{
            num += DiaN_Black[i - (current_black[i] - 1)] - 1 ;
        }
        if(num >= max){
            max = num;
            (*c) = 0;
            (*a) = i ;
        }
    }
    for(int i = 0 ; i < N ; i ++ ){
        int num = DiaP_White[current_white[i] + i - 1] - 1;
        if(i - (current_white[i] - 1) < 0){
            num += DiaN_White[i - (current_white[i] - 1) + 2 * N - 1] - 1 ;
        }
        else{
            num += DiaN_White[i - (current_white[i] - 1)] - 1 ;
        }
        if(num >= max){
            max = num;
            (*c) = 1;
            (*a) = i;
        }
    }
    if(reverse == 0 ){
        if((*c) == 0){
            for(j  = 0 ; j < N ; j ++) {
                if(j != (*a)){
                    if(current_white[j] != current_black[(*a)] && current_white[(*a)] != current_black[j] ) {
                        Delta = delta(current_black, DiaP_Black, DiaN_Black, (*a), j, N);
                        if(Delta < 0){
                            (*b) = j;
                            Ex = current_black[(*a)];
                            current_black[(*a)] = current_black[(*b)];
                            current_black[(*b)] = Ex;
                            flag = 1;
                            break;
                        }
                    }
                }
            }
        }
        else{
            for(j  = 0 ; j < N ; j ++) {
                if (j != (*a)) {
                    if(current_white[j] != current_black[(*a)] && current_white[(*a)] != current_black[j] ) {
                        Delta = delta(current_white, DiaP_White, DiaN_White, (*a), j, N);
                        if(Delta < 0) {
                            (*b) = j;
                            Ex = current_white[(*a)];
                            current_white[(*a)] = current_white[(*b)];
                            current_white[(*b)] = Ex;
                            flag = 1;
                            break;
                        }
                    }
                }
            }
        }
    }
    else{
        if((*c) == 0){
            for(j  = N - 1 ; j >= 0 ; j --) {
                if(j != (*a)){
                    if(current_white[j] != current_black[(*a)] && current_white[(*a)] != current_black[j] ) {
                        Delta = delta(current_black, DiaP_Black, DiaN_Black, (*a), j, N);
                        if(Delta < 0){
                            (*b) = j;
                            Ex = current_black[(*a)];
                            current_black[(*a)] = current_black[(*b)];
                            current_black[(*b)] = Ex;
                            flag = 1;
                            break;
                        }
                    }
                }
            }
        }
        else{
            for(j  = N - 1 ; j >= 0 ; j --) {
                if (j != (*a)) {
                    if(current_white[j] != current_black[(*a)] && current_white[(*a)] != current_black[j] ) {
                        Delta = delta(current_white, DiaP_White, DiaN_White, (*a), j, N);
                        if(Delta < 0) {
                            (*b) = j;
                            Ex = current_white[(*a)];
                            current_white[(*a)] = current_white[(*b)];
                            current_white[(*b)] = Ex;
                            flag = 1;
                            break;
                        }
                    }
                }
            }
        }
    }
    if(flag == 0){
        while(1){
            (*b) = rand()%N;
            if((*b) != (*a) && current_white[(*b)] != current_black[(*a)] && current_white[(*a)] != current_black[(*b)]){
                if((*c) == 0){
                    return delta(current_black, DiaP_Black, DiaN_Black, (*a), (*b), N);
                }
                else{
                    return delta(current_white, DiaP_White, DiaN_White, (*a), (*b), N);
                }
            }
        }
    }
    else{
        return Delta;
    }
}

void adjust(vector<int > &current_P,vector<int > &current_N,vector<int > &board,int a,int b, int N){
    current_P[board[b] + a - 1] -- ;
    if(a - (board[b] - 1) < 0){
        current_N[a - (board[b] - 1) + 2 * N - 1] --;
    }
    else {
        current_N[a - (board[b] - 1)] -- ;
    }
    current_P[board[a] + b - 1] -- ;
    if(b - (board[a] - 1) < 0){
        current_N[b - (board[a] - 1) + 2 * N - 1] -- ;
    }
    else{
        current_N[b - (board[a] - 1)] -- ;
    }
    current_P[board[a] + a - 1] ++ ;
    if(a - (board[a] - 1) < 0){
        current_N[a - (board[a] - 1) + 2 * N - 1] ++;
    }
    else{
        current_N[a - (board[a] - 1)] ++;
    }
    current_P[board[b] + b - 1] ++;
    if(b - (board[b] - 1) < 0){
        current_N[b - (board[b] - 1) + 2*N - 1] ++;
    }
    else{
        current_N[b - (board[b] - 1)] ++;
    }
}

void Adjust(vector<int > &DiaP_Black,vector<int > &DiaN_Black,vector<int > &DiaP_White,vector<int > &DiaN_White,int* H_black,int* H_white,vector<int > &current_black,vector<int > &current_white,int E,int a,int b,int c,
            int N){
    if(c == 0){// 从黑色的中选择
        adjust(DiaP_Black,DiaN_Black,current_black,a,b,N);
        (*H_black) += E;
    }
    else{
        adjust(DiaP_White,DiaN_White,current_white,a,b,N);
        (*H_white) += E;
    }
}

void Disorganize(vector<int > &board_black,vector<int > &board_white,vector<int > &DiaP_Black,vector<int > &DiaN_Black,vector<int > &DiaP_White,vector<int > &DiaN_White,int* H_black,int* H_white ,int N){
    int a,b,c;
    int Ex ;
    int Delta;
    for(int i = 0 ; i < 5 ; i ++) {
        while(1){
            while(1){
                a = rand()% N;
                b = rand()% N;
                if(a != b){
                    break;
                }
            }
            if((*H_black) > (*H_white)){
                c = 0;
            }
            else{
                c = 1;
            }
            if(board_white[b] != board_black[a] && board_white[a] != board_black[b] ){
                if(c == 0){// 从黑色的中选择
                    Delta = delta(board_black, DiaP_Black, DiaN_Black, a, b, N);
                    Ex = board_black[a];
                    board_black[a] = board_black[b];
                    board_black[b] = Ex;
                    Adjust(DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,H_black,H_white,board_black,board_white,Delta,a,b,c,N);
                }
                else{
                    Delta = delta(board_white, DiaP_White, DiaN_White, a, b, N);
                    Ex = board_white[a];
                    board_white[a] = board_white[b];
                    board_white[b] = Ex;
                    Adjust(DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,H_black,H_white,board_black,board_white,Delta,a,b,c,N);
                }
                break;
            }
        }
    }
}

int schedule(double * T ){
    (*T) = sqrt((*T));
}

int simulated_annealing(vector<int > &board_black,vector<int > &board_white, int N){
    vector<int > DiaP_Black(2 * N + 1,0);
    vector<int > DiaN_Black(2 * N + 1,0);
    vector<int > DiaP_White(2 * N + 1,0);
    vector<int > DiaN_White(2 * N + 1,0);
    int a,b,c;
    int H_black =  HeuristicFunction(board_black,DiaP_Black,DiaN_Black,N);
    int H_white =  HeuristicFunction(board_white,DiaP_White,DiaN_White,N);
    double T = N * N;
    double p,p1;
    for(int i = 0; i < log(N) ;i++ ){
        Disorganize(board_black,board_white,DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,&H_black,&H_white,N);
    }
    while(1){
        schedule(&T);
        if(H_black + H_white == 0){
            break;
        }
        else{
            int E;
            if(H_black + H_white <= 35){
                E = FindNext(board_black,board_white,DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,N,&a,&b,&c,1);
            }
            else{
                E = FindNext(board_black,board_white,DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,N,&a,&b,&c,0);
            }
            if(E > 0){
                p = exp(E * sqrt(N) * (-1) / T);
                srand((unsigned)time(0));
                p1 = ((double)rand())/RAND_MAX;
                if(p > p1){
                    Adjust(DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,&H_black,&H_white,board_black,board_white,E,a,b,c,N);
                }
            }
            else{
                Adjust(DiaP_Black,DiaN_Black,DiaP_White,DiaN_White,&H_black,&H_white,board_black,board_white,E,a,b,c,N);
            }
        }
    }
    return H_black+H_white;
}

int main(){
    int N;
    ReadFromFile(&N);
    vector<int> board_black(N,0);
    vector<int> board_white(N,0);
    if(N % 2 == 0){  // N 为偶数的时候只要对称过去即可
        N_Queen(board_black,N);
        for(int i = 0 ; i < N ; i ++){
            board_white[i] = N + 1 - board_black[i];
        }
        //TODO print
    }
    else{  //N为odd的时候需要用爬山算法
        int k;
        int random;
        int Ex;
        int H_black;
        int H_white;
        N_Queen(board_black,N);
        for(int i = 0 ; i < N ; i ++){
            if(board_black[i]  == N + 1 - board_black[i]){
                k = i;
            }
            board_white[i] = N + 1 - board_black[i];
        }
        srand((unsigned)time(0));
        while(1){
            random = rand()%N;
            if(random != k){
                break;
            }
        }
        Ex = board_black[random];
        board_black[random] = board_black[k];
        board_black[k] = Ex;
        while( simulated_annealing(board_black,board_white,N) != 0 ){}
        vector<int > DiaP_Black(2 * N + 1,0);
        vector<int > DiaN_Black(2 * N + 1,0);
        vector<int > DiaP_White(2 * N + 1,0);
        vector<int > DiaN_White(2 * N + 1,0);
        H_black =  HeuristicFunction(board_black,DiaP_Black,DiaN_Black,N);
        H_white =  HeuristicFunction(board_white,DiaP_White,DiaN_White,N);
        printf("done! %d ",H_black+H_white);
    }
}



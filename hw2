#include <stdio.h>
#include <iostream>
#include <queue>
#include <set>
#include <cstdlib>
#include <time.h>

using namespace std;
#define size 3
#define layer 3

//input and target

//define Node structure which contain 3 items:
//1.current state
//2.h function
//3.g function
struct location_target{
    int i;
    int j;
    int k;
};

struct Node{
    vector<int> state;  //current state of this node;
    int bla_layer; //the position of blank
    int bla_x;
    int bla_y;
    int h;
    int g;
    string process;   //save the process of the answer
};

struct Position{
     vector<int > position;
};

vector<int> input(27);
vector<int> target(27);
vector<location_target> a(27);
vector<Position> h(27);

struct cmp{
    bool operator()(Node* a,Node* b){
        return ((a->h) + (a->g)) >  (b->h) + (b->g);
    }
};

//number of misplaced tiles
void HeuristicFunction(Node* node){
    int i,j,k;
    node->h = 0;
    for(i = 0 ; i < layer ;i ++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size; k++){
                if(node->state[i*layer*size + j * size + k] != -1 ){
                    (node->h) += h[node->state[i*layer*size + j * size + k]].position[i*layer*size + j * size + k];
                }
            }
        }
    }
}

void Counth(int b){
    int i,j,k;
    for(i = 0 ; i < layer;i++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size ; k ++){
                h[b].position.push_back(abs(i - a[b].i)  + abs(j - a[b].j)  + abs(k - a[b].k));
            }
        }
    }
}

void ReadFromFile(Node* root){ //read input and target from files
    int i,j,k;
    FILE* finput;
    FILE* ftarget;
    if((finput = fopen("D:\\ah2\\input.txt","r")) == NULL){
        printf("\nConnot open file!");
        exit(1);
    }
    if((ftarget = fopen("D:\\ah2\\target.txt","r")) == NULL){
        printf("\nConnot open file!");
        exit(1);
    }
    for(i = 0 ; i < layer ;i ++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size; k++){
                fscanf(finput,"%d",&input[i*layer*size + j*size + k ]);
                root->state.push_back(input[i*layer*size + j*size + k ]) ;
                if(input[i*layer*size + j*size + k ] == 0){
                    root->bla_layer = i;
                    root->bla_x = j;
                    root->bla_y = k;
                }
                fscanf(ftarget,"%d",&target[i*layer*size + j*size + k ]);
                if(target[i*layer*size + j*size + k] != -1){
                    a[target[i*layer*size + j*size + k]].i =  i;
                    a[target[i*layer*size + j*size + k]].j =  j;
                    a[target[i*layer*size + j*size + k]].k =  k;
                    Counth(target[i*layer*size + j*size + k]);
                }
            }
        }
    }
    fclose(finput);
    fclose(ftarget);
}

bool CompareState(Node* node){
    int i,j,k;
    bool same = true;
    for(i = 0 ; i < layer ;i ++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size; k++){
                if(node->state[i*layer*size + j*size + k ] != target[i*layer*size + j*size + k ]){
                    same = false;
                }
            }
        }
    }
    return same;
}

bool SetInfo(Node* newnode,Node* ExpandNode,Node* root,string c){
    int Ex;
    newnode->g = (ExpandNode ->g) + 1;
    if(c.compare("U") == 0){ //up
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = (ExpandNode->bla_x )- 1 ;
        newnode->bla_y = ExpandNode->bla_y;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)-1) * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)-1) * size + ExpandNode->bla_y] = Ex;
    }
    else if(c.compare("D") == 0){
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = (ExpandNode->bla_x ) + 1 ;
        newnode->bla_y = ExpandNode->bla_y;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)+1) * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)+1) * size + ExpandNode->bla_y] = Ex;
    }
    else if(c.compare("L") == 0){
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = (ExpandNode->bla_y) - 1;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) - 1];
        newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) - 1] = Ex;
    }
    else if(c.compare("R") == 0){
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = (ExpandNode->bla_y) + 1;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) + 1];
        newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) + 1] = Ex;
    }
    else if(c.compare("F") == 0){
        newnode->bla_layer = (ExpandNode->bla_layer) - 1;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = ExpandNode->bla_y ;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[((ExpandNode->bla_layer) - 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[((ExpandNode->bla_layer) - 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] = Ex;
    }
    else if(c.compare("B") == 0){
        newnode->bla_layer = (ExpandNode->bla_layer) + 1;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = ExpandNode->bla_y ;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[((ExpandNode->bla_layer) + 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[((ExpandNode->bla_layer) + 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] = Ex;
    }
    newnode->process = ExpandNode == root ? c :  ExpandNode->process + c;
    HeuristicFunction(newnode);
    return true;
}

int main(){
    set<vector<int> > record[27];
    Node* root = new Node; //root of the tree
    Node* ExpandNode; // the node to be expanded
    priority_queue<Node*,vector<Node*>,cmp >que;
    priority_queue<Node*,vector<Node*>,cmp >PreExpandque;
    vector<int> s;
    clock_t start, finish;
    double totaltime;
    ReadFromFile(root);
    start = clock();
    root->g = 0;
    root->process = " ";
    HeuristicFunction(root);
    que.push(root);
    s = root->state;
    record[root->bla_layer * layer * size + root->bla_x * size + root->bla_y ].insert(s);
    while(!que.empty() || !PreExpandque .empty()){
        if(!PreExpandque.empty()){
            ExpandNode = PreExpandque.top();
            PreExpandque.pop();
        }
        else{
            ExpandNode = que.top();
            que.pop();
        }
        if(CompareState(ExpandNode)){
            break;
        }
        if(ExpandNode->bla_x != 0 ){ //up
            if(ExpandNode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)-1) * size + ExpandNode->bla_y] != -1){
                Node* newnode = new Node;
                if(SetInfo(newnode,ExpandNode,root,"U")){//set information
                    s = newnode->state;
                    int p = newnode->bla_layer * layer * size + newnode->bla_x * size + newnode->bla_y;
                    if(record[p].find(s) != record[p].end()){
                        free(newnode);
                    }
                    else{
                        if(newnode->g + newnode->h < ExpandNode->g + ExpandNode->h){
                            record[p].insert(s);
                            PreExpandque.push(newnode);
                        }
                        else{
                            record[p].insert(s);
                            que.push(newnode);
                        }
                    }
                }
            }
        }
        if(ExpandNode->bla_x != 2){ //down
            if(ExpandNode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)+1) * size + ExpandNode->bla_y]){
                Node* newnode = new Node;
                if(SetInfo(newnode,ExpandNode,root,"D")){
                    s = newnode->state;
                    int p = newnode->bla_layer * layer * size + newnode->bla_x * size + newnode->bla_y;
                    if(record[p].find(s) != record[p].end()){
                        delete newnode;
                    }
                    else{
                        if(newnode->g + newnode->h < ExpandNode->g + ExpandNode->h){
                            record[p].insert(s);
                            PreExpandque.push(newnode);
                        }
                        else{
                            record[p].insert(s);
                            que.push(newnode);
                        }
                    }
                } //set information
            }
        }
        if(ExpandNode->bla_y != 0){ //left
            if(ExpandNode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) - 1] != -1){
                Node* newnode = new Node;
                if(SetInfo(newnode,ExpandNode,root,"L")){//set information)
                    s = newnode->state;
                    int p = newnode->bla_layer * layer * size + newnode->bla_x * size + newnode->bla_y;
                    if(record[p].find(s) != record[p].end()){
                        delete newnode;
                    }
                    else{
                        if(newnode->g + newnode->h < ExpandNode->g + ExpandNode->h){
                            record[p].insert(s);
                            PreExpandque.push(newnode);
                        }
                        else{
                            record[p].insert(s);
                            que.push(newnode);
                        }
                    }
                }

            }
        }
        if(ExpandNode->bla_y != 2){ //right
            if(ExpandNode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) + 1] != -1){
                Node* newnode = new Node;
                if(SetInfo(newnode,ExpandNode,root,"R")){
                    s = newnode->state;
                    int p = newnode->bla_layer * layer * size + newnode->bla_x * size + newnode->bla_y;
                    if(record[p].find(s) != record[p].end()){
                        delete newnode;
                    }
                    else{
                        if(newnode->g + newnode->h < ExpandNode->g + ExpandNode->h){
                            record[p].insert(s);
                            PreExpandque.push(newnode);
                        }
                        else{
                            record[p].insert(s);
                            que.push(newnode);
                        }
                    }
                } //set information
            }
        }
        if(ExpandNode->bla_layer != 0){ //forward
            if(ExpandNode->state[((ExpandNode->bla_layer) - 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] != -1){
                Node* newnode = new Node;
                if( SetInfo(newnode,ExpandNode,root,"F") ){
                    s = newnode->state;
                    int p = newnode->bla_layer * layer * size + newnode->bla_x * size + newnode->bla_y;
                    if(record[p].find(s) != record[p].end()){
                        delete newnode;
                    }
                    else{
                        if(newnode->g + newnode->h < ExpandNode->g + ExpandNode->h){
                            record[p].insert(s);
                            PreExpandque.push(newnode);
                        }
                        else{
                            record[p].insert(s);
                            que.push(newnode);
                        }
                    }
                }//set information
            }
        }
        if(ExpandNode->bla_layer != 2){ //backward
            if(ExpandNode->state[((ExpandNode->bla_layer) + 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] != -1){
                Node* newnode = new Node;
                if(SetInfo(newnode,ExpandNode,root,"B")){
                    //insert into queue
                    s = newnode->state;
                    int p = newnode->bla_layer * layer * size + newnode->bla_x * size + newnode->bla_y;
                    if(record[p].find(s) != record[p].end()){
                        delete newnode;
                    }
                    else{
                        if(newnode->g + newnode->h < ExpandNode->g + ExpandNode->h){
                            record[p].insert(s);
                            PreExpandque.push(newnode);
                        }
                        else{
                            record[p].insert(s);
                            que.push(newnode);
                        }
                    }
                } //set information
            }
        }
        if(ExpandNode != root){
            delete ExpandNode;
        }
    }
    finish = clock();
    totaltime = (double)(finish-start)/CLOCKS_PER_SEC;
    printf("%f\n",totaltime);
    printf("step = %d\n", ExpandNode->g);
    cout<<ExpandNode->process<<endl;
    return 0;
}

#include <stdio.h>
#include <stdlib.h>
#include <queue>
#include <set>
#include <string>
#include <iostream>
using namespace std;

#define size 3
#define layer 3

//int input[layer][size][size];  //input and target
vector<int> input(27);
vector<int> target(27);

struct Node{
    vector<int> state;  //current state of this node;
    int bla_layer; //the position of blank
    int bla_x;
    int bla_y;
    int h ;
    int g ;
    string process ;   //save the process of the answer
};

struct cmp{
    bool operator()(Node* a,Node* b){
        return ((a->h) + (a->g)) >  (b->h) + (b->g);
    }
};

//number of misplaced tiles
void HeuristicFunction(Node* node){
    int i,j,k;
    node->h = 0;
    for(i = 0 ; i < layer ;i ++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size; k++){
                if( node->state[i*layer*size + j * size + k] != target[i*layer*size + j * size + k] ){
                    (node->h)++;
                }
            }
        }
    }
}

void ReadFromFile(Node* root){ //read input and target from files
    int i,j,k;
    FILE* finput;
    FILE* ftarget;
    if((finput = fopen("D:\\IDAh1\\input.txt","r")) == NULL){
        printf("\nConnot open file!");
        exit(1);
    }
    if((ftarget = fopen("D:\\IDAh1\\target.txt","r")) == NULL){
        printf("\nConnot open file!");
        exit(1);
    }
    for(i = 0 ; i < layer ;i ++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size; k++){
                fscanf(finput,"%d",&input[i*layer*size + j*size + k ]);
                root->state.push_back(input[i*layer*size + j*size + k ]) ;
                if(input[i*layer*size + j*size + k ] == 0){
                    root->bla_layer = i;
                    root->bla_x = j;
                    root->bla_y = k;
                }
                fscanf(ftarget,"%d",&target[i*layer*size + j*size + k ]);
            }
        }
    }
    fclose(finput);
    fclose(ftarget);
}

bool CompareState(Node* node){
    int i,j,k;
    bool same = true;
    for(i = 0 ; i < layer ;i ++){
        for(j = 0 ; j < size ; j ++){
            for(k = 0 ; k < size; k++){
                if(node->state[i*layer*size + j*size + k ] != target[i*layer*size + j*size + k ]){
                    same = false;
                }
            }
        }
    }
    return same;
}

bool SetInfo(Node* newnode,Node* ExpandNode,Node* root,string c){
    int Ex;
    newnode->g = (ExpandNode ->g) + 1;
    if(c.compare("U") == 0){ //up
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = (ExpandNode->bla_x )- 1 ;
        newnode->bla_y = ExpandNode->bla_y;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)-1) * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)-1) * size + ExpandNode->bla_y] = Ex;
    }
    else if(c.compare("D") == 0){
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = (ExpandNode->bla_x ) + 1 ;
        newnode->bla_y = ExpandNode->bla_y;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)+1) * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)+1) * size + ExpandNode->bla_y] = Ex;
    }
    else if(c.compare("L") == 0){
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = (ExpandNode->bla_y) - 1;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) - 1];
        newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) - 1] = Ex;
    }
    else if(c.compare("R") == 0){
        newnode->bla_layer = ExpandNode->bla_layer;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = (ExpandNode->bla_y) + 1;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) + 1];
        newnode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) + 1] = Ex;
    }
    else if(c.compare("F") == 0){
        newnode->bla_layer = (ExpandNode->bla_layer) - 1;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = ExpandNode->bla_y ;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[((ExpandNode->bla_layer) - 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[((ExpandNode->bla_layer) - 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] = Ex;
    }
    else if(c.compare("B") == 0){
        newnode->bla_layer = (ExpandNode->bla_layer) + 1;
        newnode->bla_x = ExpandNode->bla_x ;
        newnode->bla_y = ExpandNode->bla_y ;
        newnode->state = ExpandNode->state;
        Ex = newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[ExpandNode->bla_layer * layer*size +  ExpandNode->bla_x * size + ExpandNode->bla_y] = newnode->state[((ExpandNode->bla_layer) + 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y];
        newnode->state[((ExpandNode->bla_layer) + 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] = Ex;
    }
    newnode->process = ExpandNode == root ? c :  ExpandNode->process + c;
    HeuristicFunction(newnode);
    return true;
}


int main(){
    int d_limit;
    Node* root = new Node; //root of the tree
    Node* ExpandNode; // the node to be expanded
    ReadFromFile(root);
    root->g = 0;
    root->process = " ";
    HeuristicFunction(root);
    d_limit = root->g + root->h;
    while(d_limit < INT_MAX){
        int next_limit = INT_MAX;
        priority_queue<Node*,vector<Node*>,cmp>que;
        set<vector<int> > record;
        que.push(root);
        record.insert(root->state);
        while (!que.empty()){
            ExpandNode = que.top();
            que.pop();
            if((ExpandNode->g + ExpandNode->h) > d_limit){
                next_limit = (next_limit > (ExpandNode->g + ExpandNode->h)) ? (ExpandNode->g + ExpandNode->h) : next_limit;
                if(ExpandNode != root){
                    free(ExpandNode);
                }
            }
            else {
                if(CompareState(ExpandNode)){
                    printf("step = %d\n", ExpandNode->g);
                    cout<<ExpandNode->process<<endl;
                    return 0;
                }
                if(ExpandNode->bla_x != 0 ){ //up
                    if(ExpandNode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)-1) * size + ExpandNode->bla_y] != -1){
                        Node* newnode = new Node;
                        if(SetInfo(newnode,ExpandNode,root,"U")){//set information
                            if(record.find(newnode->state) != record.end()){
                                free(newnode);
                            }
                            else{
                                record.insert(newnode->state);
                                que.push(newnode);
                            }
                        }
                    }
                }
                if(ExpandNode->bla_x != 2){ //down
                    if(ExpandNode->state[ExpandNode->bla_layer*layer*size +  ((ExpandNode->bla_x)+1) * size + ExpandNode->bla_y]){
                        Node* newnode = new Node;
                        if(SetInfo(newnode,ExpandNode,root,"D")){
                            if(record.find(newnode->state) != record.end()){
                                free(newnode);
                            }
                            else{
                                record.insert(newnode->state);
                                que.push(newnode);
                            }
                        } //set information
                    }
                }
                if(ExpandNode->bla_y != 0){ //left
                    if(ExpandNode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) - 1] != -1){
                        Node* newnode = new Node;
                        if(SetInfo(newnode,ExpandNode,root,"L")){//set information)
                            if(record.find(newnode->state) != record.end()){
                                free(newnode);
                            }
                            else{
                                record.insert(newnode->state);
                                que.push(newnode);
                            }
                        }

                    }
                }
                if(ExpandNode->bla_y != 2){ //right
                    if(ExpandNode->state[ExpandNode->bla_layer * layer * size +  ExpandNode->bla_x * size + (ExpandNode->bla_y) + 1] != -1){
                        Node* newnode = new Node;
                        if(SetInfo(newnode,ExpandNode,root,"R")){
                            if(record.find(newnode->state) != record.end()){
                                free(newnode);
                            }
                            else{
                                record.insert(newnode->state);
                                que.push(newnode);
                            }
                        } //set information
                    }
                }
                if(ExpandNode->bla_layer != 0){ //forward
                    if(ExpandNode->state[((ExpandNode->bla_layer) - 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] != -1){
                        Node* newnode = new Node;
                        if( SetInfo(newnode,ExpandNode,root,"F") ){
                            if(record.find(newnode->state) != record.end()){
                                free(newnode);
                            }
                            else{
                                record.insert(newnode->state);
                                que.push(newnode);
                            }
                        }//set information
                    }
                }
                if(ExpandNode->bla_layer != 2){ //backward
                    if(ExpandNode->state[((ExpandNode->bla_layer) + 1)*layer*size + ExpandNode->bla_x * size + ExpandNode->bla_y] != -1){
                        Node* newnode = new Node;
                        if(SetInfo(newnode,ExpandNode,root,"B")){
                            //insert into queue
                            if(record.find(newnode->state) != record.end()){
                                free(newnode);
                            }
                            else{
                                record.insert(newnode->state);
                                que.push(newnode);
                            }
                        }; //set information
                    }
                }
                if(ExpandNode != root){
                    free(ExpandNode);
                }
            }
        }
        d_limit = next_limit;
    }
    return 0;
}
